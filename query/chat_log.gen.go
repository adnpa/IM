// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/adnpa/IM/model"
)

func newChatLog(db *gorm.DB, opts ...gen.DOOption) chatLog {
	_chatLog := chatLog{}

	_chatLog.chatLogDo.UseDB(db, opts...)
	_chatLog.chatLogDo.UseModel(&model.ChatLog{})

	tableName := _chatLog.chatLogDo.TableName()
	_chatLog.ALL = field.NewAsterisk(tableName)
	_chatLog.MsgID = field.NewString(tableName, "msg_id")
	_chatLog.SendID = field.NewString(tableName, "send_id")
	_chatLog.SessionType = field.NewInt32(tableName, "session_type")
	_chatLog.RecvID = field.NewString(tableName, "recv_id")
	_chatLog.ContentType = field.NewInt32(tableName, "content_type")
	_chatLog.MsgFrom = field.NewInt32(tableName, "msg_from")
	_chatLog.Content = field.NewString(tableName, "content")
	_chatLog.Remark = field.NewString(tableName, "remark")
	_chatLog.SenderPlatformID = field.NewInt32(tableName, "sender_platform_id")
	_chatLog.SendTime = field.NewTime(tableName, "send_time")

	_chatLog.fillFieldMap()

	return _chatLog
}

type chatLog struct {
	chatLogDo

	ALL              field.Asterisk
	MsgID            field.String
	SendID           field.String
	SessionType      field.Int32
	RecvID           field.String
	ContentType      field.Int32
	MsgFrom          field.Int32
	Content          field.String
	Remark           field.String
	SenderPlatformID field.Int32
	SendTime         field.Time

	fieldMap map[string]field.Expr
}

func (c chatLog) Table(newTableName string) *chatLog {
	c.chatLogDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c chatLog) As(alias string) *chatLog {
	c.chatLogDo.DO = *(c.chatLogDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *chatLog) updateTableName(table string) *chatLog {
	c.ALL = field.NewAsterisk(table)
	c.MsgID = field.NewString(table, "msg_id")
	c.SendID = field.NewString(table, "send_id")
	c.SessionType = field.NewInt32(table, "session_type")
	c.RecvID = field.NewString(table, "recv_id")
	c.ContentType = field.NewInt32(table, "content_type")
	c.MsgFrom = field.NewInt32(table, "msg_from")
	c.Content = field.NewString(table, "content")
	c.Remark = field.NewString(table, "remark")
	c.SenderPlatformID = field.NewInt32(table, "sender_platform_id")
	c.SendTime = field.NewTime(table, "send_time")

	c.fillFieldMap()

	return c
}

func (c *chatLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *chatLog) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 10)
	c.fieldMap["msg_id"] = c.MsgID
	c.fieldMap["send_id"] = c.SendID
	c.fieldMap["session_type"] = c.SessionType
	c.fieldMap["recv_id"] = c.RecvID
	c.fieldMap["content_type"] = c.ContentType
	c.fieldMap["msg_from"] = c.MsgFrom
	c.fieldMap["content"] = c.Content
	c.fieldMap["remark"] = c.Remark
	c.fieldMap["sender_platform_id"] = c.SenderPlatformID
	c.fieldMap["send_time"] = c.SendTime
}

func (c chatLog) clone(db *gorm.DB) chatLog {
	c.chatLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c chatLog) replaceDB(db *gorm.DB) chatLog {
	c.chatLogDo.ReplaceDB(db)
	return c
}

type chatLogDo struct{ gen.DO }

type IChatLogDo interface {
	gen.SubQuery
	Debug() IChatLogDo
	WithContext(ctx context.Context) IChatLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IChatLogDo
	WriteDB() IChatLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IChatLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IChatLogDo
	Not(conds ...gen.Condition) IChatLogDo
	Or(conds ...gen.Condition) IChatLogDo
	Select(conds ...field.Expr) IChatLogDo
	Where(conds ...gen.Condition) IChatLogDo
	Order(conds ...field.Expr) IChatLogDo
	Distinct(cols ...field.Expr) IChatLogDo
	Omit(cols ...field.Expr) IChatLogDo
	Join(table schema.Tabler, on ...field.Expr) IChatLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IChatLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IChatLogDo
	Group(cols ...field.Expr) IChatLogDo
	Having(conds ...gen.Condition) IChatLogDo
	Limit(limit int) IChatLogDo
	Offset(offset int) IChatLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IChatLogDo
	Unscoped() IChatLogDo
	Create(values ...*model.ChatLog) error
	CreateInBatches(values []*model.ChatLog, batchSize int) error
	Save(values ...*model.ChatLog) error
	First() (*model.ChatLog, error)
	Take() (*model.ChatLog, error)
	Last() (*model.ChatLog, error)
	Find() ([]*model.ChatLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ChatLog, err error)
	FindInBatches(result *[]*model.ChatLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ChatLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IChatLogDo
	Assign(attrs ...field.AssignExpr) IChatLogDo
	Joins(fields ...field.RelationField) IChatLogDo
	Preload(fields ...field.RelationField) IChatLogDo
	FirstOrInit() (*model.ChatLog, error)
	FirstOrCreate() (*model.ChatLog, error)
	FindByPage(offset int, limit int) (result []*model.ChatLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IChatLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c chatLogDo) Debug() IChatLogDo {
	return c.withDO(c.DO.Debug())
}

func (c chatLogDo) WithContext(ctx context.Context) IChatLogDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c chatLogDo) ReadDB() IChatLogDo {
	return c.Clauses(dbresolver.Read)
}

func (c chatLogDo) WriteDB() IChatLogDo {
	return c.Clauses(dbresolver.Write)
}

func (c chatLogDo) Session(config *gorm.Session) IChatLogDo {
	return c.withDO(c.DO.Session(config))
}

func (c chatLogDo) Clauses(conds ...clause.Expression) IChatLogDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c chatLogDo) Returning(value interface{}, columns ...string) IChatLogDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c chatLogDo) Not(conds ...gen.Condition) IChatLogDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c chatLogDo) Or(conds ...gen.Condition) IChatLogDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c chatLogDo) Select(conds ...field.Expr) IChatLogDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c chatLogDo) Where(conds ...gen.Condition) IChatLogDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c chatLogDo) Order(conds ...field.Expr) IChatLogDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c chatLogDo) Distinct(cols ...field.Expr) IChatLogDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c chatLogDo) Omit(cols ...field.Expr) IChatLogDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c chatLogDo) Join(table schema.Tabler, on ...field.Expr) IChatLogDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c chatLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IChatLogDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c chatLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IChatLogDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c chatLogDo) Group(cols ...field.Expr) IChatLogDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c chatLogDo) Having(conds ...gen.Condition) IChatLogDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c chatLogDo) Limit(limit int) IChatLogDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c chatLogDo) Offset(offset int) IChatLogDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c chatLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IChatLogDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c chatLogDo) Unscoped() IChatLogDo {
	return c.withDO(c.DO.Unscoped())
}

func (c chatLogDo) Create(values ...*model.ChatLog) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c chatLogDo) CreateInBatches(values []*model.ChatLog, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c chatLogDo) Save(values ...*model.ChatLog) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c chatLogDo) First() (*model.ChatLog, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatLog), nil
	}
}

func (c chatLogDo) Take() (*model.ChatLog, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatLog), nil
	}
}

func (c chatLogDo) Last() (*model.ChatLog, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatLog), nil
	}
}

func (c chatLogDo) Find() ([]*model.ChatLog, error) {
	result, err := c.DO.Find()
	return result.([]*model.ChatLog), err
}

func (c chatLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ChatLog, err error) {
	buf := make([]*model.ChatLog, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c chatLogDo) FindInBatches(result *[]*model.ChatLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c chatLogDo) Attrs(attrs ...field.AssignExpr) IChatLogDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c chatLogDo) Assign(attrs ...field.AssignExpr) IChatLogDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c chatLogDo) Joins(fields ...field.RelationField) IChatLogDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c chatLogDo) Preload(fields ...field.RelationField) IChatLogDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c chatLogDo) FirstOrInit() (*model.ChatLog, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatLog), nil
	}
}

func (c chatLogDo) FirstOrCreate() (*model.ChatLog, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatLog), nil
	}
}

func (c chatLogDo) FindByPage(offset int, limit int) (result []*model.ChatLog, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c chatLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c chatLogDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c chatLogDo) Delete(models ...*model.ChatLog) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *chatLogDo) withDO(do gen.Dao) *chatLogDo {
	c.DO = *do.(*gen.DO)
	return c
}
