

https://bytebytego.com/courses/system-design-interview/design-a-chat-system

# 步骤1 明白问题和涉及范围

* 一对一聊天应用，如 Facebook Messenger、微信和 WhatsApp
* 群聊的办公聊天应用，如 Slack
* 大群组互动和低语音聊天延迟的游戏聊天应用，如 Discord。

需要考虑的问题

* 哪种类型
* 在什么平台
* 规模
* 群组成员限制
* 需要那些功能：一对一聊天，群聊，在线指示器。系统仅支持文本消息。
* 消息长度限制：100,000字符
* 端到端加密
* 聊天记录保存多久：永久



# 步骤2 提出顶层设计



对客户端和服务端通信的基本了解：使用cs架构，通过中间的chat service提供服务，该服务有以下基本功能

* 从其他client接受信息
* 为每条消息正确找到收件人并转发
* 接受者不在线，则保留离线消息直到用户上线



当客户端试图创建一个会话时，需要通过某种网络协议向服务器发送消息，网络协议的选择至关重要。和典型的cs架构应用一样，im也是由客户端发起连接。

使用http协议的keep-alive选项，可以维护一个长连接，发送端可以轻松的发送消息。

但是http不支持由服务端发送消息，所以需要使用其他协议，如polling, long polling, and WebSocket等

## polling轮询

客户端**定期向服务器询问是否有新的消息**，即拉模型，根据拉取频率，可能会消耗昂贵服务器资源。



## long polling长轮询

长轮询即**没有新消息时服务器不回复，而是等到超时**，客户端再发起新连接，直到有新的消息或者超时。缺点如下：

* 发送者和接收者可能不会连接到同一个聊天服务器。基于 HTTP 的服务器通常是无状态的。如果您使用循环机制进行负载平衡，则接收消息的服务器可能没有与接收消息的客户端建立长轮询连接。
* 服务器没有好的方法来判断客户端是否已断开连接。
* 效率很低。如果用户聊天不多，长轮询在超时后仍会定期建立连接。



## WebSocket

推模型，服务端向客户端发送异步更新的最常用的方法。

以 HTTP 连接开始，可以通过一些明确定义的握手“升级”为 WebSocket 连接。通过此持久连接，服务器可以向客户端发送更新。

**简化设计，不再使用http发送消息，收发都由websocket完成。**

**由于 WebSocket 连接是持久的，因此高效的连接管理在服务器端至关重要。**



## 顶层设计

### 无状态服务stateless

*  login
*  signup
*  user profile

用户请求通过负载均衡器被导向正确的服务，可以是微服务也可以是单体。

不需要自己构建无状态服务，可以使用第三方。需深入讨论的一个服务是服务发现。它的主要作用是向客户端提供客户端可以连接的聊天服务器的 DNS 主机名列表。



### 有状态服务 stateful

唯一有状态的服务是聊天服务。该服务是有状态的，因为每个客户端都与聊天服务器保持持久的网络连接。在此服务中，只要服务器仍然可用，客户端通常不会切换到另一个聊天服务器。服务发现与聊天服务紧密协调，以避免服务器过载。我们将深入探讨细节。



### 第三方third party

对于聊天应用来说，推送通知（手机弹窗等）是最重要的第三方集成。它是一种在有新消息到达时通知用户的方式，即使应用未运行。正确集成推送通知至关重要。



### 伸缩性

服务器可以处理的并发连接数很可能是限制因素。

假设有 1M 个并发用户的情况下，假设每个用户连接需要服务器上 10K 的内存（这是一个非常粗略的数字，并且非常依赖于语言选择），它只需要大约 10GB 的内存来容纳一个盒子上的所有连接。

* 聊天服务器便于发送/接收消息。 
* 在线状态服务器管理在线/离线状态。 
* API 服务器处理所有事务，包括用户登录、注册、更改个人资料等。
* 通知服务器发送推送通知。 
* 键值存储用于存储聊天历史记录。当离线用户上线时，她将看到她之前的所有聊天历史记录。





## 存储选择

关系数据库还是 NoSQL 数据库？为了做出明智的决定，我们将检查**数据类型**和**读/写模式**。



* 通用数据，如用户资料，设置，好友等，存储在强大而可靠的关系数据库中。复制和分片是满足可用性和可扩展性要求的常用技术。
* 聊天数据
  * 特点
    * 数据量大
    * 只有最新数据经常被访问
    * 虽然一般只访问最新数据，但可能需要随机检索功能，如搜索聊天记录等。
    * 一对一聊天应用来说，读写比约为 1:1
  * 使用kv数据库
  * 易于水平扩展。 
  * 低数据访问延迟 
  * 关系数据库不能很好地处理长尾数据 [3]。当索引变大时，随机访问的成本很高。 其他经过验证的可靠聊天应用程序也采用键值存储。例如，Facebook messenger 和 Discord 都使用键值存储。Facebook messenger 使用 HBase [4]，而 Discord 使用 Cassandra [5]。



## 数据模型



message

* id bigint
* from bigint
* to bigint
* content text
* created_at

依赖message_id决定消息顺序，因为不同消息可以同时创建

group_message

* channel_id bigint
* message_id bigint
* user_id bigint
* content text
* created_at

混合主键 channel id+message_id



### 消息id生成

需满足

* ID 必须是唯一的。 
* ID 应该可以按时间排序，这意味着新行的 ID 高于旧行。

首先想到的是 MySql 中的“auto_increment”关键字。然而，NoSQL 数据库通常不提供这样的功能。

第二种方法是使用像 Snowflake [6] 这样的全局 64 位序列号生成器。这在“在分布式系统中设计唯一 ID 生成器”一章中进行了讨论。

最后一种方法是使用本地序列号生成器。本地意味着 ID 仅在组内是唯一的。本地 ID 之所以有效，是因为在一对一通道或组通道内维护消息序列就足够了。与全局 ID 实现相比，这种方法更容易实现。











# 步骤3 深入设计



在系统设计面试中，通常需要深入研究高级设计中的某些组件。对于聊天系统、服务发现、消息流和在线/离线指标，值得深入探索。



## 服务发现

服务发现的主要功能是根据地理位置、服务器容量等标准为客户端推荐最佳聊天服务器。可以使用热门的开源解决方案**zookeeper**，它注册所有可用的聊天服务器，并根据预定义的标准为客户端选择最佳聊天服务器。

1. 用户尝试登录
2. 负载均衡器将登录请求发送至 API 服务器
3. 后端对用户进行身份验证后，服务发现会为用户 A 找到最佳聊天服务器。在此示例中，选择了服务器 2，并将服务器信息返回给用户 A。
4. 用户A通过WebSocket连接聊天服务器2。



* api服务器
* 聊天服务器，即ws服务器，用户用ws连接到该服务器使用聊天服务









## 消息流

### 1对1 信息流 

1. 发送聊天消息。
2. 聊天服务器 1 从 ID 生成器获取消息 ID。 
3. 聊天服务器 1 将消息发送到消息同步队列。
4. 消息存储在键值存储中。
5. * a. 如果用户 B 在线，则将消息转发到用户 B 连接的聊天服务器 2
   * b. 如果用户 B 离线，则从推送通知 (PN) 服务器发送推送通知。
6. 聊天服务器 2 将消息转发给用户 B。用户 B 和聊天服务器 2 之间存在持久的 WebSocket 连接。

### 多设备消息同步

用户 A 有两台设备：一部手机和一台笔记本电脑。当用户 A 使用手机登录聊天应用程序时，它会与聊天服务器 1 建立 WebSocket 连接。同样，笔记本电脑和聊天服务器 1 之间也有一个连接。

每个设备都会维护一个名为 cur_max_message_id 的变量，用于跟踪设备上的最新消息 ID。满足以下两个条件的消息被视为新闻消息：

* 收件人 ID 等于当前登录的用户 ID。
* 键值存储中的消息 ID 大于 cur_max_message_id。

由于每台设备上具有不同的 cur_max_message_id，因此消息同步变得容易，因为每台设备都可以从 KV 存储中获取新消息。

### 小群聊信息流

假设群组中有 3 名成员（用户 A、用户 B 和用户 C）。当用户 A 在群聊中发送消息时，首先，来自用户 A 的消息被**复制到每个群组成员的消息同步队列**：一个给用户 B，另一个给用户 C。您可以将消息同步队列视为收件人的收件箱。这种设计选择适用于小型群聊，因为：

* 它简化了消息同步流程，因为每个客户端只需要检查自己的收件箱即可获取新消息。 
* 当群组数量较少时，在每个收件人的收件箱中存储一份副本的成本并不太高。

微信采用了类似的方法，并将群组限制为 500 名成员。然而，对于拥有大量用户的群组来说，为每个成员保存消息副本是不可接受的。

小群使用写扩散模式，

对于大群一般使用读扩散模式



## 在线状态

在高层设计中，在线状态服务器负责管理在线状态并通过 WebSocket 与客户端通信。有几个流程会触发在线状态更改。让我们逐一检查一下。

### 用户登录

用户登录流程在“服务发现”部分中进行了说明。在客户端和实时服务之间建立 WebSocket 连接后，用户 A 的在线状态和 last_active_at 时间戳将保存在 KV 存储中。用户登录后，在线状态指示器显示用户在线。

### 用户注销

当用户注销时，它会经历如图 17 所示的用户注销流程。在线状态在 KV 存储中更改为离线。在线指示器显示用户处于离线状态。

### 断开连接

* 处理用户断线的一个简单方法是将用户标记为离线，并在连接重新建立时将状态更改为在线。问题是断线太常见，用户可能短时间多次重联。在线状态频繁变化会导致用户体验不佳。
* 引入了心跳机制来解决这个问题。在线客户端会定期向在线状态服务器发送心跳事件。如果在线状态服务器在一定时间内（例如 x 秒）收到来自客户端的心跳事件，则认为用户在线。否则，用户处于离线状态。
  例如客户端每 5 秒向服务器发送一次心跳事件。发送 3 次心跳事件后，客户端断开连接，并且在 x = **30 秒内未重新连接**（此数字是任意选择的，以演示逻辑）。在线状态更改为离线。

### 在线状态fan out

A的好友如何知道状态变化？

状态服务器使用发布-订阅模型，其中每对好友维护一个频道。这三个频道分别由用户 B、C 和 D 订阅。因此，好友可以轻松获取在线状态更新。客户端和服务器之间的通信是通过实时 WebSocket 进行的

上述设计对于小规模的用户群是有效的。例如，微信就采用了类似的方法，因为其用户群上限为 500 人。对于较大的群组，通知所有成员在线状态既昂贵又耗时。假设一个群组有 100,000 名成员。每次状态更改都会生成 100,000 个事件。为了解决性能瓶颈，一种可能的解决方案是仅在用户进入群组或手动刷新好友列表时获取在线状态。





# Ref

## 相关文章

* [从无到有：微信后台系统的演进之路](https://www.infoq.cn/article/the-road-of-the-growth-weixin-background)

## 相关项目

https://opensource.com/article/20/4/open-source-chat

* matrix https://matrix.org/
* Rocket.Chat https://github.com/RocketChat/Rocket.Chat
  终极解决方案，综合通信平台，将频道分为公共（向任何加入者开放）或私人（仅限邀请）房间。您还可以向已登录的人发送直接消息；共享文档、链接、照片、视频和 GIF；进行视频通话；无需离开平台即可发送音频消息。
* IRC
  实时的、基于文本的通信形式。尽管它是最古老的电子通信形式之一
* Zulip
  流行的群聊应用程序，遵循基于主题的线程模型。在 Zulip 中，您可以订阅流，就像在 IRC 频道或 Rocket.Chat 中一样。但每个 Zulip 流都会打开一个独特的主题，这有助于您以后跟踪对话，从而使其更有条理。
* Let's Chat 
  面向小型团队的自托管聊天解决方案。它基于 Node.js 和 MongoDB 运行，只需单击几下即可部署到本地服务器或托管服务。它是免费且开源的，源代码可在 GitHub 上找到。
* Bonus: Open source **video chat** with Jitsi

https://github.com/nahid/talk