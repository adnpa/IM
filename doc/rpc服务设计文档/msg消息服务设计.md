有状态服务,和在线状态服务配合



别名,ws长连接服务



## 需求

* 实时性
* 可靠性
* 一致性



## 结构设计

| 字段 | 说明                                       |
| ---- | ------------------------------------------ |
| req  | 序列号                                     |
| ope  | 0单聊；1群聊                               |
| from | 发送者id                                   |
| to   | 接收者id                                   |
| type | 消息类型                                   |
| body | 消息正文，json格式，根据消息类型不同而不同 |
| ex   | 扩展字段                                   |



## 存储策略

由于需要支持数据漫游和历史消息，结合数据特点，使用mongodb全量存储





## 保证实时性

架构：cs模型->全双工

演化：短轮询（客户端询问是否有新消息）->长轮询（客户端询问是否有新消息，若无，服务器不响应，直到超时，客户端发起新连接）->全双工实时（客户端回调，服务器有新消息推送）

协议：http->websocket、TCP

消息到达后，服务器根据在线状态，若在线，需要实时转发，若不在线，上线后马上进行消息同步





## 可靠性

消息的不丢失和不重复

主要利用类似tcp的**超时、重传、确认**机制

1）已明确被对方收到；
2）已明确未被对方收到。

即使使用“可靠的传输协议”TCP，也不能保证聊天消息的可靠性，如客户端写入db前应用崩溃关机等

**收发过程**

以client A向client B发送消息为例

1. client A -> server
   1. A向服务器发送消息（带timeout）
   2. * 服务器收到消息并成功写入数据库，向A发送ack（消息不丢）
      * 服务器未收到消息，A超时显示**未发送**，由A主动发起重传
2. server -> client B
   1. * server带超时向client 发送，超时重新加入重发队列
      * 在线，直接向B发送
      * 不在线，存储到历史消息队列，B上线时主动从队列拉取
   2. B收到消息向服务器发送ack，从队列中删去此消息

离线消息优化

1. 客户端上线主动拉取消息
2. 采用批量ack，而不是对每条消息都发送ack。所有的离线消息按会话进行分组，每组回复一个ACK，假如某个ACK丢失，则只需要重传该会话的所有离线消息。



## 一致性

单聊消息而言，保证同一个设备的时间顺序、不同设备的漫游同步

1）单聊时：要保证发送方发出聊天消息的顺序与接收方看到的顺序一致；
2）群聊时：要保证所有群员看到的聊天消息，与发送者发出消息时的绝对时间序是一致的。

**主要由id服务实现，id服务生成的id保证 时序**

一对一单聊时，其实只需要保证发出的时序与接收的时序一致，就基本能让用户感觉不到乱序了。

多对多的群聊情况下，保证同一群内的所有接收方消息时序一致，也就能让用户感觉不到乱序了，方法有两种，一种单点绝对时序，另一种实现**消息id的序列化**（也就是实现一种全局递增消息ID）。



id实现

https://blog.csdn.net/qq_36034503/article/details/124463015







## 数据流模式

解耦方案，每个用户创建一个消息同步队列（类型于收件箱inbox），不使用共享队列（避免锁竞争和开销）

### 1对1 信息流 

1. 发送聊天消息。
2. 聊天服务器 1 从 ID 生成器获取消息 ID。 
3. 聊天服务器 1 将消息发送到消息同步队列。
4. 消息存储在键值存储中。
5. * a. 如果用户 B 在线，则将消息转发到用户 B 连接的聊天服务器 2
   * b. 如果用户 B 离线，则从推送通知 (PN) 服务器发送推送通知。
6. 聊天服务器 2 将消息转发给用户 B。用户 B 和聊天服务器 2 之间存在持久的 WebSocket 连接。

### 多设备消息同步

用户 A 有两台设备：一部手机和一台笔记本电脑。当用户 A 使用手机登录聊天应用程序时，它会与聊天服务器 1 建立 WebSocket 连接。同样，笔记本电脑和聊天服务器 1 之间也有一个连接。

每个设备都会维护一个名为 cur_max_message_id 的变量，用于跟踪设备上的最新消息 ID。满足以下两个条件的消息被视为新闻消息：

* 收件人 ID 等于当前登录的用户 ID。
* 键值存储中的消息 ID 大于 cur_max_message_id。

由于每台设备上具有不同的 cur_max_message_id，因此消息同步变得容易，因为每台设备都可以从 KV 存储中获取新消息。

### 小群聊信息流

http://www.52im.net/thread-1616-1-1.html

存储结构

group_info(gid, group_info);
user_info(uid, user_info);
group_members(gid, uid);



由于堆积等情况，用户对每个群总是记录最新收到的msgId，之后的收发采用批量ack

和一对一方案类似，区别是复制了三份消息。

假设群组中有 3 名成员（用户 A、用户 B 和用户 C）。当用户 A 在群聊中发送消息时，首先，来自用户 A 的消息被**复制到每个群组成员的消息同步队列**：一个给用户 B，另一个给用户 C。您可以将消息同步队列视为收件人的收件箱。这种设计选择适用于小型群聊，因为：

* 它简化了消息同步流程，因为每个客户端只需要检查自己的收件箱即可获取新消息。 
* 当群组数量较少时，在每个收件人的收件箱中存储一份副本的成本并不太高。

微信采用了类似的方法，并将群组限制为 500 名成员。然而，对于拥有大量用户的群组来说，为每个成员保存消息副本是不可接受的。

收件时，每个在群聊都有一份 {msgId, groupId, senderID, myId}，(写扩散)

小群可以使用写扩散模式，对于大群一般使用读扩散模式







群聊消息处理

根据群id找到加群用户 发送过去

方案1 

map[user]{group1 group2}

锁的频率低 需轮询所有user

方案2

map[GroupId]{user1 user2...}

* 找用户很快
* 发送信息需要根据userid获取node，锁的频次高

选择哪种方案和业务场景有关

